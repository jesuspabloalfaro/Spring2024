# Design and Implementation
## Operating System Design and Implementation
- Design and Implementation of IS does not have a "perfect solution", but some approaches have proven successful
- Internal structure of different Operating Systems can vary widely
- Start the design by defining goals and specifications
- Affected by choice of hardware and type of system
- **User** goals and **System** goals
	- User Goals: 
		- Operating systems should be convenient to use, easy to learn, reliable, safe and fast
	- System Goals:
		- Operating system should be easy to design, implement, and maintain, as well as flexible, reliable, error-free, and efficient
- Important principle to separate
	- **Policy**: *What* will be done
	- **Mechanisms**: *How* to do it
- *Mechanisms* determine how to do something, policies device what will be done
- The separation of policy from mechanism is a very important principle. It allows maximum flexibility if policy decisions are to be changed later. Need flexible parametrized mechanisms
- Examples
	- Timer construct is a mechanism for ensuring protection, but duration setting is a policy
	- Priority scheduling is a mechanism, but which kinds of processes get higher priority is a policy
- Specifying and designing an OS is highly creative task of *software engineering*
## Implementation
- Much variation
	- Early OSes in assembly language
	- Then system programming languages like Algol, PL/1
	- Now C, C++
- Actually usually a mix of languages
	- Lowest levels in assembly
	- Main body in C
	- Systems programs in C, C++, scripting languages like PERL, Python
- Linux and Windows kernels are mostly written in C
- High-level language is easier to port to other hardware
	- Linux is written in C and is available on Intel x86, Oracle SPARC and IBM PowerPC
	- MS-DOS and early versions of Windows were written in Intel x86 Assembly and ran only on Intel x86 HW